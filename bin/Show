#!/usr/bin/env python

import mpv
import sys
import argparse
import os
from types import SimpleNamespace

from libshow.db import Db

SHOW_EXTENSIONS = [
    'mkv',
    'avi',
    'mpg',
    'mp4',
    'mpeg',
    'ogv',
    'wmv',
    'flv',
    'm4v',
    'iso',
    'mov'
]

def log_mpv(loglevel, component, message):
    print('[{}] {}: {}'.format(loglevel, component, message))

"""If path is a directory then load series into db and return next unwatched show else return path to file"""
def path_to_video(db, path):
    if os.path.isdir(path):
        db.load_series(path)
        video_entry = db.get_next_in_series()
        if not video_entry:
            raise ValueError('series is complete')
        video_path = os.path.join(path, video_entry['video'])
        return video_path, video_entry
    else:
        return path, None

def display_video(path):
    db = Db()
    video_path, _ = path_to_video(db, path)
    print(os.path.basename(video_path))

def watch_video(path):
    player = mpv.MPV(log_handler=log_mpv, input_default_bindings=True, input_vo_keyboard=True, fullscreen=True)

    session = SimpleNamespace(position=None)

    @player.on_key_press('q')
    def quit_binding():
        session.position = player.time_pos
        player.quit()

    db = Db()
    video_path, video_entry = path_to_video(db, path)

    player.play(video_path)

    # get duration of video
    def set_duration(x):
        if x:
            session.duration = x
            return True
    player.wait_for_property('duration', set_duration, False)

    # wait for video to end
    player.wait_for_playback()

    if session.position is None:
        session.position = session.duration

    if video_entry:
        # TODO: format duration as 00:00:00
        video_entry['duration'] = str(session.duration)
        print('recording watched video:', video_entry['video'])
        db.write_series(path)

def is_video(path):
    for suffix in SHOW_EXTENSIONS:
        if path.endswith('.' + suffix):
            return True
    return False

def create_show_db(dirpath, force):
    db = Db()

    # TODO: merge new content with old content instead
    if not force and os.path.isfile(db.get_series_db_path(dirpath)):
        raise ValueError('new database already exists')

    for filename in sorted(os.listdir(dirpath)):
        if is_video(filename):
            db.add_show_to_series(filename)

    db.write_series(dirpath)


def convert_show_db(dirpath, force):
    db = Db()
    if not force and os.path.isfile(db.get_series_db_path(dirpath)):
        raise ValueError('new database already exists')

    new_filepath = db.get_series_db_path(dirpath)
    db.load_series_v0(dirpath)
    db.write_series(dirpath)

def main():
    parser = argparse.ArgumentParser(description='enjoy your videos')
    parser.add_argument('-c', '--create', action='store_true', help='create series database for videos in current directory')
    parser.add_argument('-C', '--convert', action='store_true', help='convert series database to new version')
    parser.add_argument('-f', '--force', action='store_true', help='force overwrite etc.')
    parser.add_argument('-p', '--print', action='store_true', help='display video(s) that would be played')
    parser.add_argument('paths', help='paths to videos or series directories', nargs='*')
    args = parser.parse_args()

    def get_cwd_or_paths():
        paths = args.paths
        return [ os.getcwd() ] if not paths else paths

    if args.create:
        for path in get_cwd_or_paths():
            create_show_db(path, args.force)
    elif args.convert:
        for path in get_cwd_or_paths():
            convert_show_db(path, args.force)
    elif args.print:
        for path in get_cwd_or_paths():
            display_video(path)
    else:
        for path in get_cwd_or_paths():
            watch_video(path)

try:
    main()
except ValueError as err:
    print(err.args[0])
