#!/usr/bin/env python

import mpv
import sys
import argparse
from datetime import datetime
import os
from types import SimpleNamespace

from libshow.db import Db

SHOW_EXTENSIONS = [
    'mkv',
    'avi',
    'mpg',
    'mp4',
    'mpeg',
    'ogv',
    'wmv',
    'flv',
    'm4v',
    'iso',
    'mov'
]

def log_mpv(loglevel, component, message):
    print('[{}] {}: {}'.format(loglevel, component, message))

"""If path is a directory then load series into db and return next unwatched show else return path to file"""
def path_to_video(db, path):
    if os.path.isdir(path):
        db.load_series(path)
        video_entry = db.get_next_in_series()
        if not video_entry:
            raise ValueError('series is complete')
        video_path = os.path.join(path, video_entry['video'])
        return video_path, video_entry
    else:
        return path, None

def display_video(path):
    db = Db()
    video_path, _ = path_to_video(db, path)
    print(os.path.basename(video_path))

def format_date(date):
    return str(date).replace('-', '/')

def format_duration(duration):
    # TODO: format as hh:mm:ss.sss
    return str(duration)

def parse_duration(duration):
    # TODO: parse format hh:mm:ss.sss
    return float(duration)

def watch_video(path):
    player = mpv.MPV(log_handler=log_mpv, input_default_bindings=True, input_vo_keyboard=True, fullscreen=True)

    session = SimpleNamespace(position=None)

    @player.on_key_press('Q')
    @player.on_key_press('q')
    def quit_binding():
        session.position = player.time_pos
        player.quit()

    db = Db()
    video_path, video_entry = path_to_video(db, path)

    start_time = datetime.now()
    player.play(video_path)
    viewings = video_entry and video_entry.get('viewings', None)

    # get duration of video
    def set_duration(x):
        if x:
            session.duration = x
            return True
    player.wait_for_property('duration', set_duration, False)

    # once the duration has been read it seems to be safe to seek
    if viewings:
        final_viewing = viewings[-1]['end'].split(' at ')[1]
        player.seek(parse_duration(final_viewing))

    # wait for video to end
    player.wait_for_playback()
    end_time = datetime.now()

    if session.position is None:
        session.position = session.duration

    if video_entry:
        duration = format_duration(session.duration)
        if video_entry.get('duration', None) != duration:
            video_entry['duration'] = duration
        viewings = video_entry.setdefault('viewings', [])

        viewings.append({
            'start':  format_date(start_time),
            'end':  format_date(end_time) + ' at ' + format_duration(session.position)
        })
        print('recording watched video:', video_entry['video'])
        db.write_series(path)

def is_video(path):
    for suffix in SHOW_EXTENSIONS:
        if path.endswith('.' + suffix):
            return True
    return False

def create_show_db(dirpath, force):
    db = Db()

    # TODO: merge new content with old content instead
    if not force and os.path.isfile(db.get_series_db_path(dirpath)):
        raise ValueError('new database already exists')

    for filename in sorted(os.listdir(dirpath)):
        if is_video(filename):
            db.add_show_to_series(filename)

    db.write_series(dirpath)


def convert_show_db(dirpath, force):
    db = Db()
    if not force and os.path.isfile(db.get_series_db_path(dirpath)):
        raise ValueError('new show db already exists')

    new_filepath = db.get_series_db_path(dirpath)
    db.load_series_v0(dirpath)
    db.write_series(dirpath)

def convert_global_show_db(force):
    db = Db()
    if not force and os.path.isfile(db.get_global_record_db_path()):
        raise ValueError('new global record already exists')
    db.load_global_record_v0()
    db.write_global_record()

def main():
    parser = argparse.ArgumentParser(description='enjoy your videos')
    parser.add_argument('-c', '--create', action='store_true', help='create series database for videos in current directory')
    parser.add_argument('-C', '--convert', action='store_true', help='convert series database to new version')
    parser.add_argument('--convert-global', action='store_true', help='convert global series database to new version')
    parser.add_argument('-f', '--force', action='store_true', help='force overwrite etc.')
    parser.add_argument('-p', '--print', action='store_true', help='display video(s) that would be played')
    parser.add_argument('paths', help='paths to videos or series directories', nargs='*')
    args = parser.parse_args()

    def get_cwd_or_paths():
        paths = args.paths
        return [ os.getcwd() ] if not paths else paths

    if args.create:
        for path in get_cwd_or_paths():
            create_show_db(path, args.force)
    elif args.print:
        for path in get_cwd_or_paths():
            display_video(path)
    elif args.convert:
        for path in get_cwd_or_paths():
            convert_show_db(path, args.force)
    elif args.convert_global:
        convert_global_show_db(args.force)
    else:
        for path in get_cwd_or_paths():
            watch_video(path)

try:
    main()
except ValueError as err:
    print(err.args[0])
